{"version":3,"sources":["webpack:///webpack/bootstrap 9f969da4ccc74b55e6bc","webpack:///./entry2.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,cAAc;AAClC;AACA;AACA,sBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,qEAAqE;AACtF,oBAAmB,wEAAwE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA,kBAAiB,sDAAsD;AACvE,oBAAmB,yDAAyD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB,sDAAsD;AACtE,kBAAiB,yDAAyD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,YAAY;AAC5B;AACA;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA,mBAAkB,MAAM;AACxB,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,uDAAuD;AACvE,kBAAiB,0DAA0D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,WAAW,UAAU,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,wDAAwD;AAC3E,sBAAqB,2DAA2D;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,wDAAwD;AAC7E,wBAAuB,2DAA2D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,wDAAwD;AAC/E,0BAAyB,2DAA2D;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;;AAGA;AACA;AACA;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9f969da4ccc74b55e6bc\n **/","\n\ndocument.addEventListener(\"DOMContentLoaded\", function(){\n   const canvas = document.getElementById(\"canvas\");\n  // const ctx = canvasEl.getContext(\"2d\");\n  let tetris = new Tetris(canvas).run();\n  // new Tetris(ctx).start();\n\n});\n\n\n\nclass Tetris {\n  constructor(canvas){\n    this.onkeydown =this.onkeydown.bind(this)\n    this.active = [];\n    this.dead = [];\n    this.tetrisBlocks=[];\n    this.backgorund;\n    this.hid;\n    this.activeTetris;\n    this.nextTetrisBlock;\n    this.nextTetrisBlock2;\n    this.nextTetrisBlock3;\n    this.nextTetrisBlock4;\n    this.currentRotation;\n    this.level = 1;\n    this.currentTetrisRow;\n    this.currentTetrisCol;\n    this.timeCount;\n    this.next_t;\n    this.next_t2;\n    this.next_t3;\n    this.next_t4;\n    this.pause = false;\n    this.gameOver = false;\n    this.bonus = false;\n    this.row = 20;\n    this.col = 10;\n    this.size = 22;\n    this.colors =[];\n    this.canvas = canvas;\n    this.score = 0;\n    this.firstRenderOfScore = true;\n    this.scoreNeededToLevel = 500;\n    this.nextTetrisBlock2 =Math.floor(Math.random()*7);\n    this.nextTetrisBlock3 =Math.floor(Math.random()*7);\n    this.nextTetrisBlock4 =Math.floor(Math.random()*7);\n    this.start_twice = 0;\n\n  }\n  run(){\n    this.stage = new createjs.Stage(this.canvas);\n    this.background();\n    this.setTetris();\n    this.nextTetrisBlock = Math.floor(Math.random()*7);\n    this.renderTetris();\n    createjs.Ticker.setFPS(100);\n    createjs.Ticker.addEventListener(\"tick\",this.stage);\n    this.stage.update();\n    let _this = this;\n    window.addEventListener('keydown',_this.onkeydown);\n    var startTxt = new createjs.Text(' s to start', 'Bold 14px Helvetica', '#000000');\n    var resetTxt = new createjs.Text(' r to restart', 'Bold 14px Helvetica', '#000000');\n    var arrowTxt = new createjs.Text(' arrow keys to move', 'Bold 14px Helvetica', '#000000');\n    startTxt.x=this.size*(this.col+1);\n    startTxt.y=360;\n    resetTxt.x=this.size*(this.col+1);\n    resetTxt.y=380;\n    arrowTxt.x=this.size*(this.col+1);\n    arrowTxt.y=400;\n    this.stage.addChild(startTxt);\n    this.stage.addChild(resetTxt);\n    this.stage.addChild(arrowTxt);\n    // if(start_twice ===  0 ){\n    //   start_twice++;\n    //   this.run();\n    // }\n\n  }\n\n\n\n    background() {\n\n    \tlet backgorund = new createjs.Shape();\n    \tthis.hid = new createjs.Shape();\n    \tthis.hid.graphics.beginFill('#ffffff');\n    \tthis.hid.graphics.rect(0,this.size*2,this.size*this.col,this.size*(this.row));\n    \tbackgorund.mask = this.hid;\n    \tbackgorund.graphics.beginStroke('#000000');\n    \tfor (let i = 0; i < this.row; i++) {\n    \t\tthis.active[i] = [];\n    \t\tthis.dead[i] = [];\n    \t\tfor (let j = 0; j < this.col; j++) {\n    \t\t\tthis.active[i][j]=0;\n    \t\t\tthis.dead[i][j]=null;\n          // var image = new Image();\n          // image.onload = function(){\n          //\n          // }\n          let block  = new createjs.Bitmap(\"./tetris_blocks2.0/dark_tetris2.0.png\");\n          // this.stage.addChild(this.block);\n          // this.stage.update();\n\n          // this.stage.addChild(this.block);\n          let _this = this;\n           block.image.onload = function() {\n\n            _this.stage.update();\n            backgorund.graphics.beginBitmapFill(block.image).rect(_this.size*j,_this.size*i,_this.size,_this.size);\n            backgorund.graphics.endFill();\n            // image.src = `tetris_blocks2.0/light_tetris2.0.png`;\n            // _this.backgorund.graphics.beginFill(_this.backgorundColors[((j % 2) + (i % 2)) % 2], 0);\n            _this.stage.addChild(backgorund);\n            _this.stage.update();\n          }\n    \t\t\t// this.backgorund.graphics.rect(this.size*j,this.size*i,this.size,this.size);\n    \t\t}\n    \t}\n    }\n\n  setTetris() {\n  \tthis.tetrisBlocks[0]=[\n      [\n        [0,0,0,0],\n        [1,1,1,1],\n        [0,0,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [1,0,0,0],\n        [1,0,0,0],\n        [1,0,0,0],\n        [1,0,0,0]\n      ]];\n  \tthis.colors[0]=\"./tetris_blocks2.0/light_blue_tetris2.0.png\";\n  \tthis.tetrisBlocks[1]=[\n      [\n        [0,0,0,0],\n        [1,1,1,0],\n        [0,1,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,0,0],\n        [0,1,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,1,0],\n        [0,0,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,1,0,0],\n        [0,0,0,0]]];\n  \tthis.colors[1]=\"./tetris_blocks2.0/purple_tetris2.0.png\";\n  \tthis.tetrisBlocks[2]=[\n      [\n        [0,0,0,0],\n        [1,1,1,0],\n        [1,0,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [1,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,0,1,0],\n        [1,1,1,0],\n        [0,0,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,0,0,0]\n      ]\n    ];\n  \tthis.colors[2]=\"./tetris_blocks2.0/dark_blue_tetris2.0.png\";\n  \tthis.tetrisBlocks[3]=[\n      [\n        [0,0,0,0],\n        [1,0,0,0],\n        [1,1,1,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,1,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,0,0,0],\n        [1,1,1,0],\n        [0,0,1,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,0,0],\n        [1,1,0,0],\n        [0,0,0,0]\n      ]\n    ];\n  \tthis.colors[3]=\"./tetris_blocks2.0/orange_tetris2.0.png\";\n  \tthis.tetrisBlocks[4]=[\n      [\n        [0,0,0,0],\n        [1,1,0,0],\n        [0,1,1,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,1,1,0],\n        [0,1,0,0],\n        [0,0,0,0]\n      ]\n    ];\n  \tthis.colors[4]=\"./tetris_blocks2.0/red_tetris2.0.png\";\n  \tthis.tetrisBlocks[5]=[\n      [\n        [0,0,0,0],\n        [0,1,1,0],\n        [1,1,0,0],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,0,1,0],\n        [0,0,0,0]\n      ]\n    ];\n  \tthis.colors[5]=\"./tetris_blocks2.0/green_tetris2.0.png\";\n  \tthis.tetrisBlocks[6]=[\n      [\n        [0,0,0,0],\n        [0,1,1,0],\n        [0,1,1,0],\n        [0,0,0,0]\n      ]\n    ];\n  \tthis.colors[6]=\"./tetris_blocks2.0/yellow_tetris2.0.png\";\n  }\n  check(row, col, rot) {\n    let ct=this.activeTetris;\n    for (let i=0; i<this.tetrisBlocks[this.activeTetris][this.currentRotation].length; i++) {\n      for (let j=0; j<this.tetrisBlocks[this.activeTetris][this.currentRotation][i].length; j++) {\n        if (this.tetrisBlocks[this.activeTetris][this.currentRotation][i][j]==1) {\n          if (col+j<0 || (col + j > this.col - 1) || (row+i>this.row-1) || (this.active[row+i][col+j]==1) ){\n             return false;\n           }\n        }\n      }\n    }\n    return true;\n  }\n  renderTetris(time = 500){\n  \tif (this.gameOver) return;\n  \tthis.activeTetris=this.nextTetrisBlock;\n    this.nextTetrisBlock = this.nextTetrisBlock2;\n    this.nextTetrisBlock2 = this.nextTetrisBlock3;\n    this.nextTetrisBlock3 = this.nextTetrisBlock4;\n    this.nextTetrisBlock4=Math.floor(Math.random()*7);\n  \tthis.currentRotation=0;\n  \tthis.currentTetrisRow=1;\n  \tthis.currentTetrisCol=3;\n  \tthis.drawTetrisBlock();\n  \tthis.drawNext();\n    this.drawNext2();\n    this.drawNext3();\n    this.drawNext4();\n  \tif (this.check(this.currentTetrisRow,this.currentTetrisCol,this.currentRotation)) {\n  \t\tclearTimeout(this.timeCount);\n      let _this = this;\n  \t\tthis.timeCount = setInterval(this.onTime.bind(this), (time - (this.level *75)));\n  \t} else {\n  \t\tthis.gameOver=true;\n  \t}\n\n  }\n  drawTetrisBlock() {\n  \tlet ct=this.activeTetris;\n  \tthis.tetrisBlock = new createjs.Shape();\n\n\n\n\n  \t// this.stage.addChild(this.tetrisBlock);\n  \t// this.tetrisBlock.mask = this.masker;\n  \tthis.tetrisBlock.graphics.beginStroke('#111111');\n    for (var i=0; i<this.tetrisBlocks[ct][this.currentRotation].length; i++) {\n      for (var j=0; j<this.tetrisBlocks[ct][this.currentRotation][i].length; j++) {\n  \t\t\tif (this.tetrisBlocks[ct][this.currentRotation][i][j]==1) {\n  \t\t\t\t// this.tetrisBlock.graphics.beginFill(this.colors[ct]);\n  \t\t\t\t// this.tetrisBlock.graphics.drawRect(this.size*j,this.size*i,this.size,this.size);\n          this.block = new createjs.Bitmap(this.colors[ct]);\n          // this.stage.addChild(this.block);\n          let _this = this;\n          this.block.image.onload = function() {\n            _this.stage.update();\n          }\n          this.tetrisBlock.graphics.beginBitmapFill(this.block.image).rect(this.size*j,this.size*i,this.size,this.size);\n          this.stage.addChild(this.tetrisBlock);\n\n  \t\t\t}\n  \t\t}\n  \t}\n  \tthis.placeTetrisBlock();\n    this.stage.update();\n  }\n  placeTetrisBlock() {\n  \tthis.tetrisBlock.x=this.currentTetrisCol*this.size;\n  \tthis.tetrisBlock.y=this.currentTetrisRow*this.size;\n  }\n  pause(){\n    this.pause = true;\n  }\n  unPause(){\n    this.pause = false;\n  }\n  onkeydown(e) {\n  \tswitch (e.keyCode) {\n      case 80:\n        if(this.pause){\n        this.pause();\n      } else{\n        this.unPause();\n      }\n      e.preventDefault();\n      case 82:\n        this.active = [];\n        this.dead = [];\n        this.tetrisBlocks=[];\n        this.backgorund;\n        this.hid;\n        this.activeTetris;\n        this.nextTetrisBlock;\n        this.nextTetrisBlock2;\n        this.nextTetrisBlock3;\n        this.nextTetrisBlock4;\n        this.currentRotation;\n        this.currentTetrisRow;\n        this.currentTetrisCol;\n        this.timeCount;\n        this.next_t;\n        this.next_t2;\n        this.next_t3;\n        this.next_t4;\n        this.pause = false;\n        this.gameOver = false;\n        this.bonus = false;\n        this.firstRenderOfScore = true;\n        this.colors =[];\n        this.score =0;\n        this.level=1;\n        this.scoreNeededToLevel = 500;\n        this.run();\n      e.preventDefault();\n      break;\n      case 83:\n        this.active = [];\n        this.dead = [];\n        this.tetrisBlocks=[];\n        this.backgorund;\n        this.hid;\n        this.level =1;\n        this.activeTetris;\n        this.nextTetrisBlock;\n        this.nextTetrisBlock2;\n        this.nextTetrisBlock3;\n        this.nextTetrisBlock4;\n        this.currentRotation;\n        this.currentTetrisRow;\n        this.currentTetrisCol;\n        this.timeCount;\n        this.next_t;\n        this.next_t2;\n        this.next_t3;\n        this.next_t4;\n        this.pause = false;\n        this.gameOver = false;\n        this.bonus = false;\n        this.firstRenderOfScore = true;\n        this.colors =[];\n        this.score =0;\n        this.scoreNeededToLevel = 500;\n        this.run();\n      e.preventDefault();\n      break;\n  \t\tcase 37 :\n  \t\tif (this.gameOver || this.pause) return;\n  \t\tif (this.check(this.currentTetrisRow,this.currentTetrisCol-1,this.currentRotation)) {\n  \t\t\tthis.currentTetrisCol--;\n  \t\t\tthis.placeTetrisBlock();\n  \t\t}\n  \t\te.preventDefault();\n  \t\tbreak;\n  \t\tcase 39 :\n  \t\tif (this.gameOver || this.pause) return;\n  \t\tif (this.check(this.currentTetrisRow,this.currentTetrisCol+1,this.currentRotation)) {\n  \t\t\tthis.currentTetrisCol++;\n  \t\t\tthis.placeTetrisBlock();\n  \t\t}\n  \t\te.preventDefault();\n  \t\tbreak;\n  \t\tcase 38 :\n  \t\tif (this.gameOver || this.pause) return;\n  \t\tif (this.currentTetrisRow < 0) this.currentTetrisRow = 0;\n  \t\tif (this.currentTetrisCol < 0) this.currentTetrisCol = 0;\n  \t\tif (this.currentTetrisCol > this.col - this.tetrisBlocks[this.activeTetris][this.currentRotation].length)\n  \t\t\tthis.currentTetrisCol = this.col - this.tetrisBlocks[this.activeTetris][this.currentRotation].length;\n  \t\tlet ct=this.currentRotation;\n  \t\tlet tmpRow = this.currentTetrisRow;\n  \t\tlet tmpCol = this.currentTetrisCol;\n  \t\tlet tmpRot = ct;\n  \t\tlet rot = (ct + 1) % this.tetrisBlocks[this.activeTetris].length;\n  \t\tif (this.check(this.currentTetrisRow, this.currentTetrisCol, rot)) {\n  \t\t\tthis.currentRotation=rot;\n  \t\t\tthis.stage.removeChild(this.tetrisBlock);\n  \t\t\tthis.drawTetrisBlock();\n  \t\t\tthis.placeTetrisBlock();\n  \t\t}\n  \t\tif(!this.check(this.currentTetrisRow, this.currentTetrisCol, rot)) {\n  \t\t\tthis.currentRotation = tmpRot;\n  \t\t\tthis.currentTetrisCol = tmpCol;\n  \t\t\tthis.currentTetrisRow = tmpRow;\n  \t\t\tthis.stage.removeChild(this.tetrisBlock);\n  \t\t\tthis.drawTetrisBlock();\n  \t\t\tthis.placeTetrisBlock();\n  \t\t}\n  \t\te.preventDefault();\n  \t\tbreak;\n  \t\tcase 40 :\n  \t\tif (this.gameOver || this.pause) return;\n  \t\tif (this.check(this.currentTetrisRow+1,this.currentTetrisCol)) {\n  \t\t\tthis.currentTetrisRow++;\n  \t\t\tthis.placeTetrisBlock();\n  \t\t} else {\n  \t\t\tthis.landTetrisBlock();\n  \t\t\tthis.renderTetris();\n  \t\t}\n  \t\te.preventDefault();\n  \t\tbreak;\n          default:break;\n  \t}\n\n  }\n  landTetrisBlock(){\n  \tlet ct=this.activeTetris;\n  \tlet landed;\n  \tfor (let i=0; i<this.tetrisBlocks[ct][this.currentRotation].length; i++) {\n  \t\tfor (let j=0; j<this.tetrisBlocks[ct][this.currentRotation][i].length; j++) {\n  \t\t\tif (this.tetrisBlocks[ct][this.currentRotation][i][j]==1) {\n  \t\t\t\tlanded = new createjs.Shape();\n  \t\t\t\t// landed.mask = this.masker;\n          landed.graphics.beginStroke('#111111');\n  \t\t\t\tlanded.graphics.beginFill(this.colors[this.activeTetris]);\n  \t\t\t\tlanded.graphics.drawRect(this.size*(this.currentTetrisCol+j),this.size*(this.currentTetrisRow+i),this.size,this.size);\n  \t\t\t\tthis.stage.addChild(landed);\n\n  \t\t\t\tthis.active[this.currentTetrisRow+i][this.currentTetrisCol+j]=1;\n\n  \t\t\t\tthis.dead[this.currentTetrisRow+i][this.currentTetrisCol+j]=landed;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tthis.stage.removeChild(this.tetrisBlock);\n\n  \tclearInterval(this.timeCount);\n  \tthis.checkForLines();\n  }\n  checkForLines() {\n    let count = 0;\n  \tfor (let i=0; i<this.row; i++) {\n  \t\tif (this.active[i].indexOf(0) == -1) {\n        count++;\n  \t\t\tfor (let j=0; j<this.col; j++) {\n  \t\t\t\tthis.active[i][j]=0;\n  \t\t\t\tthis.stage.removeChild(this.dead[i][j]);\n  \t\t\t}\n  \t\t\tfor (let j=i; j>=0; j--) {\n  \t\t\t\tfor (let k=0; k<this.col; k++) {\n  \t\t\t\t\tif (this.active[j][k]==1) {\n  \t\t\t\t\t\tthis.active[j][k]=0;\n  \t\t\t\t\t\tthis.active[j+1][k]=1;\n  \t\t\t\t\t\tthis.dead[j][k].y+=this.size;\n  \t\t\t\t\t\tthis.dead[j+1][k]=this.dead[j][k];\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n      switch(count){\n        case 1:\n          this.score =this.score + 100;\n          this.bonus = false;\n          if(this.score >= this.scoreNeededToLevel){\n            this.level =this.level + 1;\n            this.scoreNeededToLevel = this.scoreNeededToLevel + 500;\n          }\n        break;\n        case 2:\n          this.score =this.score + 200;\n          this.bonus = false;\n          if(this.score >= this.scoreNeededToLevel){\n            this.level =this.level + 1;\n            this.scoreNeededToLevel = this.scoreNeededToLevel + 500;\n          }\n        break;\n        case 3:\n          this.score =this.score + 300;\n          this.bonus = false;\n          if(this.score >= this.scoreNeededToLevel){\n            this.level =this.level + 1;\n            this.scoreNeededToLevel = this.scoreNeededToLevel + 500;\n          }\n        break;\n        case 4:\n          if(this.bonus){\n            this.score =this.score + 1200;\n            this.level =this.level + 1;\n            this.scoreNeededToLevel = this.scoreNeededToLevel + 500;\n          } else{\n            this.score =this.score + 800;\n            this.level = this.level +1\n            this.bonus = true;\n          }\n          if(this.score >= this.scoreNeededToLevel){\n            this.level =this.level + 1;\n            this.scoreNeededToLevel = this.scoreNeededToLevel + 500;\n          }\n        break;\n        default:\n        break;\n      }\n\n    }\n  onTime(){\n    if (this.pause){\n      return;\n    }\n  \tif (this.check(this.currentTetrisRow+1,this.currentTetrisCol,this.currentRotation)) {\n  \t\tthis.currentTetrisRow++;\n  \t\tthis.placeTetrisBlock();\n  \t} else {\n  \t\tthis.landTetrisBlock();\n  \t\tthis.renderTetris();\n  \t}\n  }\n  //draw next tetris\n  drawNext() {\n  \tif (this.next_t) this.stage.removeChild(this.next_t);\n  \tthis.next_t=new createjs.Shape();\n  \tthis.next_t.x=this.size*(this.col+1);\n  \tthis.next_t.y=this.size*1;\n  \tthis.stage.addChild(this.next_t);\n  \tthis.next_t.graphics.beginStroke('#111111');\n  \tfor (let i=0; i < this.tetrisBlocks[this.nextTetrisBlock][0].length; i++) {\n  \t\tfor (let j=0; j < this.tetrisBlocks[this.nextTetrisBlock][0][i].length; j++) {\n  \t\t\tif (this.tetrisBlocks[this.nextTetrisBlock][0][i][j]==1) {\n          let block = new createjs.Bitmap(this.colors[this.nextTetrisBlock]);\n          // this.stage.addChild(block);\n          let _this = this;\n          block.image.onload = function() {\n            _this.stage.update();\n            _this.next_t.graphics.beginBitmapFill(block.image).rect(_this.size*j,_this.size*i,_this.size,_this.size);\n            _this.stage.addChild(_this.next_t);\n            _this.stage.update();\n          }\n\n\n\n\n  \t\t\t\t// this.next_t.graphics.beginFill(this.colors[this.nextTetrisBlock]);\n  \t\t\t\t// this.next_t.graphics.drawRect(this.size*j,this.size*i,this.size,this.size);\n  \t\t\t\t// this.next_t.graphics.endFill();\n  \t\t\t}\n  \t\t}\n  \t}\n    // let clear = new createjs.Shape();\n  \t// clear.graphics.beginFill('#ffffff');\n  \t// clear.graphics.rect(0,this.size*2,this.size*this.col,this.size*(this.row));\n\n    if(this.firstRenderOfScore){\n      let score = ` score: ${this.score} level: ${this.level}`;\n      this.scoreTxt = new createjs.Text(score, 'Bold 14px Helvetica', '#000000');\n      this.scoreTxt.x=this.size*(this.col+1);\n      this.scoreTxt.y=420;\n      this.stage.addChild(this.scoreTxt);\n      this.firstRenderOfScore = false;\n    } else {\n      this.scoreTxt.text = \" score: \"+this.score+ \" level: \"+this.level;\n    }\n\n\n\n  }\n    drawNext2() {\n      if (this.next_t2) this.stage.removeChild(this.next_t2);\n      this.next_t2=new createjs.Shape();\n      this.next_t2.x=this.size*(this.col+1);\n      this.next_t2.y=this.size*4;\n      this.stage.addChild(this.next_t2);\n      this.next_t2.graphics.beginStroke('#111111');\n      for (let i=0; i < this.tetrisBlocks[this.nextTetrisBlock2][0].length; i++) {\n        for (let j=0; j < this.tetrisBlocks[this.nextTetrisBlock2][0][i].length; j++) {\n          if (this.tetrisBlocks[this.nextTetrisBlock2][0][i][j]==1) {\n\n             let block = new createjs.Bitmap(this.colors[this.nextTetrisBlock2]);\n            // this.stage.addChild(block);\n            let _this = this;\n            block.image.onload = function() {\n              _this.stage.update();\n              _this.next_t2.graphics.beginBitmapFill(block.image).rect(_this.size*j,_this.size*i,_this.size,_this.size);\n              _this.stage.addChild(_this.next_t2);\n              _this.stage.update();\n            }\n\n\n            // this.next_t2.graphics.beginFill(this.colors[this.nextTetrisBlock2]);\n            // this.next_t2.graphics.drawRect(this.size*j,this.size*i,this.size,this.size);\n            // this.next_t2.graphics.endFill();\n          }\n        }\n      }\n    }\n      drawNext3() {\n        if (this.next_t3) this.stage.removeChild(this.next_t3);\n        this.next_t3=new createjs.Shape();\n        this.next_t3.x=this.size*(this.col+1);\n        this.next_t3.y=this.size*8 ;\n        this.stage.addChild(this.next_t3);\n        this.next_t3.graphics.beginStroke('#111111');\n        for (let i=0; i < this.tetrisBlocks[this.nextTetrisBlock3][0].length; i++) {\n          for (let j=0; j < this.tetrisBlocks[this.nextTetrisBlock3][0][i].length; j++) {\n            if (this.tetrisBlocks[this.nextTetrisBlock3][0][i][j]==1) {\n              let block = new createjs.Bitmap(this.colors[this.nextTetrisBlock3]);\n              // this.stage.addChild(block);\n              let _this = this;\n              block.image.onload = function() {\n                _this.stage.update();\n                _this.next_t3.graphics.beginBitmapFill(block.image).rect(_this.size*j,_this.size*i,_this.size,_this.size);\n                _this.stage.addChild(_this.next_t3);\n                _this.stage.update();\n              }\n\n\n\n\n              // this.next_t3.graphics.beginFill(this.colors[this.nextTetrisBlock3]);\n              // this.next_t3.graphics.drawRect(this.size*j,this.size*i,this.size,this.size);\n              // this.next_t3.graphics.endFill();\n            }\n          }\n        }\n      }\n        drawNext4() {\n          if (this.next_t4) this.stage.removeChild(this.next_t4);\n          this.next_t4=new createjs.Shape();\n          this.next_t4.x=this.size*(this.col+1);\n          this.next_t4.y=this.size*12;\n          this.stage.addChild(this.next_t4);\n          this.next_t4.graphics.beginStroke('#111111');\n          for (let i=0; i < this.tetrisBlocks[this.nextTetrisBlock4][0].length; i++) {\n            for (let j=0; j < this.tetrisBlocks[this.nextTetrisBlock4][0][i].length; j++) {\n              if (this.tetrisBlocks[this.nextTetrisBlock4][0][i][j]==1) {\n                let block = new createjs.Bitmap(this.colors[this.nextTetrisBlock4]);\n                // this.stage.addChild(block);\n                let _this = this;\n                block.image.onload = function() {\n                  _this.stage.update();\n                  _this.next_t4.graphics.beginBitmapFill(block.image).rect(_this.size*j,_this.size*i,_this.size,_this.size);\n                  _this.stage.addChild(_this.next_t4);\n                  _this.stage.update();\n                }\n\n\n                // this.next_t4.graphics.beginFill(this.colors[this.nextTetrisBlock4]);\n                // this.next_t4.graphics.drawRect(this.size*j,this.size*i,this.size,this.size);\n                // this.next_t4.graphics.endFill();\n              }\n            }\n          }\n\n\n\n\n        }\n\n\n  tick(){\n  \tthis.stage.update();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./entry2.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}